// import { ResourceLoader } from "../helpers/loader.ts";
import postgres from "$postgres";
import * as supabase from "supabase";

export interface DatabaseUser {
  userId: number;
  userName: string;
  avatarUrl: string;
}

export class Database {
  #client: supabase.SupabaseClient;

  constructor(client?: supabase.SupabaseClient) {
    this.#client =
      client ??
      supabase.createClient(
        Deno.env.get("SUPABASE_API_URL")!,
        Deno.env.get("SUPABASE_ANON_KEY")!
      );
  }

  async insertUser(user: DatabaseUser & { accessToken: string }) {
    const { error } = await this.#client.from("users").upsert(
      [
        {
          id: user.userId,
          username: user.userName,
          avatar_url: user.avatarUrl,
          access_token: user.accessToken,
        },
      ],
      { returning: "minimal" }
    );
    if (error) {
      throw new Error(error.message);
    }
  }

  async getUserByAccessTokenOrThrow(
    accessToken: string
  ): Promise<DatabaseUser> {
    const user = await this.getUserByAccessToken(accessToken);
    if (user == null) {
      throw new Error("Could not find user with access token.");
    }
    return user;
  }

  async getUserByAccessToken(
    accessToken: string
  ): Promise<DatabaseUser | undefined> {
    const { data, error } = await this.#client
      .from("users")
      .select("id,username,avatar_url")
      .eq("access_token", accessToken);
    if (error) {
      throw new Error(error.message);
    }
    if (data.length === 0) {
      return undefined;
    }
    return {
      userId: data[0].id,
      userName: data[0].username,
      avatarUrl: data[0].avatar_url,
    };
  }
}

export interface ResourceLoaderOptions<T> {
  load(): Promise<T>;
  getTime?(): number;
  /**
   * The amount of milliseconds to wait before trying to load again if a failure occurs.
   *
   * @default 10_000
   */
  resetTimeout?: number;
}

export class ResourceLoader<T> {
  readonly #loadFunc: () => Promise<T>;
  readonly #getTime: () => number;
  readonly #resetTimeout: number;

  #instance: T | undefined;
  #loadPromise: Promise<void> | undefined;
  #errResetTime: number | undefined;

  constructor(opts: ResourceLoaderOptions<T>) {
    this.#loadFunc = opts.load;
    this.#getTime = opts.getTime ?? (() => Date.now());
    this.#resetTimeout = opts.resetTimeout ?? 1_000 * 10;
  }

  async getInstance() {
    if (this.#errResetTime && this.#getTime() > this.#errResetTime) {
      this.#errResetTime = undefined;
      this.#loadPromise = undefined;
    }

    if (!this.#instance) {
      await this.#getLoadPromise();
    }
    return this.#instance!;
  }

  #getLoadPromise() {
    if (!this.#loadPromise) {
      this.#loadPromise = this.#loadFunc()
        .then((resource) => {
          this.#instance = resource;
          this.#loadPromise = undefined;
        })
        .catch((err) => {
          // try again in a bit
          this.#errResetTime = this.#getTime() + this.#resetTimeout;
          return Promise.reject(err);
        });
    }
    return this.#loadPromise;
  }
}

export const databaseLoader = new ResourceLoader<Database>({
  async load() {
    // Automatically create the database schema on startup.
    const caCert = getEnvOrThrow("SUPABASE_CA_CERTIFICATE").replace(
      /\s+(?!CERTIFICATE--)/g,
      "\n"
    );
    const sql = postgres(getEnvOrThrow("SUPABASE_POSTGRES_URI"), {
      // NOTE - original code used boolean but that's not supported
      keep_alive: 0, // Otherwise required '--unstable' flag.
      ssl: { caCerts: [caCert] },
    });
    await sql`
      create table if not exists users (
        id integer generated by default as identity primary key,
        created_at timestamp with time zone default timezone('utc'::text, now()) not null,
        username text unique,
        avatar_url text,
        access_token text
      )`;
    await sql.end();
    return Promise.resolve(new Database());

    function getEnvOrThrow(name: string) {
      const value = Deno.env.get(name);
      if (value == null) {
        throw new Error(`Missing env variable: ${name}`);
      }
      return value;
    }
  },
});
